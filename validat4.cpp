// validat2.cpp - written and placed in the public domain by Wei Dai

#include "pch.h"

#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1

#include "cryptlib.h"
#include "pubkey.h"
#include "gfpcrypt.h"
#include "eccrypto.h"
#include "blumshub.h"
#include "filters.h"
#include "files.h"
#include "rsa.h"
#include "md2.h"
#include "elgamal.h"
#include "nr.h"
#include "dsa.h"
#include "dh.h"
#include "mqv.h"
#include "hmqv.h"
#include "fhmqv.h"
#include "luc.h"
#include "xtrcrypt.h"
#include "rabin.h"
#include "rw.h"
#include "eccrypto.h"
#include "integer.h"
#include "gf2n.h"
#include "ecp.h"
#include "ec2n.h"
#include "asn.h"
#include "rng.h"
#include "hex.h"
#include "oids.h"
#include "esign.h"
#include "osrng.h"
#include "smartptr.h"

#include <iostream>
#include <sstream>
#include <iomanip>

#include "validate.h"

// Aggressive stack checking with VS2005 SP1 and above.
#if (CRYPTOPP_MSC_VERSION >= 1410)
# pragma strict_gs_check (on)
#endif

// Quiet deprecated warnings intended to benefit users.
#if CRYPTOPP_MSC_VERSION
# pragma warning(disable: 4996)
#endif

#if CRYPTOPP_GCC_DIAGNOSTIC_AVAILABLE
# pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

USING_NAMESPACE(CryptoPP)

// Test data generated with Crypto++ 5.6.2.
bool ValidateLegacyDLIES()
{
	std::cout << "\nLegacy DLIES validation suite running...\n\n";

	bool pass = true, fail;
	static const char plain[] = "abc";

	{
		// 1024 modulus, SHA1
		static const size_t size = 620;
		static const byte cipher[size+1] =
			"\x06\x50\x83\xF2\x70\xCC\x22\x34\x99\x24\xE2\xCC\xB3\x64\x4F\x91\x24\x7E\x8C\xB2"
			"\xE3\x79\x65\x79\x5B\x64\x62\x12\x56\xF8\x2E\x68\x8D\x50\x5A\xC0\x7D\x87\x5D\x00"
			"\x09\x92\x47\x5C\x31\xBC\x21\xB9\x42\x30\x47\xD6\xF3\xD7\x36\x19\xB7\x02\xE5\x96"
			"\xBE\xF6\x99\x8C\xE1\xAB\xC1\x1D\xE2\x95\x1A\x1D\x72\x62\xEA\x7F\x2E\xF6\xD9\x01"
			"\x63\x81\x05\xA0\xFB\x15\x66\x6F\x2B\xF6\x93\xE7\x24\x1F\x92\x54\x29\x38\x53\xCC"
			"\x25\x39\x01\x80\xF1\xCA\x4A\xF6\x7F\xFA\xCD\xD9\x6A\x62\xC8\x06\xFD\x5D\x38\x74"
			"\x16\x0A\x96\xA3\x32\x91\x60\x80\x79\x01\x8E\x20\xCF\xEB\xA1\x4E\x92\xE5\x6B\xBB"
			"\x58\xA0\xA3\x04\x3E\x0D\xC4\x89\x9F\x89\xB2";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/dlies1024.dat", true, new HexDecoder);
		DLIES<SHA1,NoCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		DLIES<SHA1,NoCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

#if 0
		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "1024-bit, NoCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;
#endif

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// 2048 modulus, SHA1
		static const size_t size = 1144;
		static const byte cipher[size+1] =
			"\x95\x45\xC3\x2D\x46\x5E\x74\xFF\xEE\x98\xAE\x80\xE6\xEB\x5C\x25\x8F\xDE\x55\x29"
			"\x31\xBC\x70\x72\x04\x7D\x99\x6A\xC1\xC1\x5E\x77\xA5\x89\xDE\x9F\x8C\xAC\xDE\x6D"
			"\xBB\xA4\x7D\xA5\xE4\xE4\xEF\x54\x72\xBB\x7D\xF0\xAA\x49\x81\xFF\xE6\xEA\xB3\x1A"
			"\x1A\x68\x19\xDD\x0E\xB9\x49\x99\x46\x18\x9C\xFB\x47\xA2\xDB\xF2\xFD\x01\x37\xBC"
			"\x06\x63\x7E\x04\x39\xFE\x46\x56\x55\xD4\x6B\x5D\xC3\x9D\x69\x86\x8C\xA6\x2C\x83"
			"\xEA\x95\x78\x84\x5F\x25\xA6\x4A\x54\xA0\x14\x43\x32\xC7\x6F\x37\x3B\x7C\x95\x17"
			"\x94\xD9\xAF\x38\x10\xA3\x87\xC9\x6B\x63\xFB\x4B\x82\xB9\x73\x97\xD0\xF1\xC0\x6B"
			"\xFF\xE4\x5E\xB7\x14\xF1\xD6\x07\x00\xB4\xFF\xE9\xD1\x4A\xB0\x5F\x6A\xD1\xA0\xD6"
			"\x9A\x01\x0E\x0F\xD3\x04\x79\x4C\xA9\xEF\xE6\xDB\xB3\xF7\xFE\x72\x41\x32\x96\x3D"
			"\x2E\x9B\x40\xDC\x3D\x44\x29\x38\x84\x3A\x0D\xB6\x03\x05\x08\x0D\x19\xDD\x62\x98"
			"\xBA\x72\xF8\x29\xCE\x87\xD0\x3B\x98\xE9\xD6\x14\xF3\x7F\x23\xC0\x5E\x08\x3E\x78"
			"\xB3\x25\x36\x07\x54\x13\xF9\x3B\x2A\xD0\x1F\x1E\xBC\xA5\xA7\x1A\x2A\x92\xDF\x9E"
			"\xE3\x6B\x0A\x51\xEA\xFF\x89\x2F\x98\x27\x41\x55\xB3\xE5\x1A\x71\xA0\xF1\x52\x5D"
			"\xFA\x3B\x44\xD9\xEA\xDD\xDA\x7D\x58\xF0\x65\xAA\x0A\x98\x9F\xDB\x38\xD5\x8A";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/dlies2048.dat", true, new HexDecoder);
		DLIES<SHA1,NoCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		DLIES<SHA1,NoCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

#if 0
		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "2048-bit, NoCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;
#endif

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// 1024 modulus, SHA1
		static const size_t size = 620;
		static const byte cipher[size+1] =
			"\x17\x48\x21\x11\xC8\x87\xDB\x41\x9A\x75\x6D\x1B\xF4\xCB\x8A\x82\xA2\x65\x87"
			"\x9F\xFA\xCB\x07\x8C\xBE\x22\x08\x90\x71\xA4\xB8\xC1\xD8\x44\x33\x03\xF7\x5F"
			"\xEA\x18\x57\xA9\x95\xD1\x8A\xC5\x29\x8F\xF8\x48\x04\x63\xC7\x43\xDD\x34\x04"
			"\x56\x4C\xD4\xC3\x4A\x98\xC0\x8C\x3E\xC4\x7B\xE3\x6B\xE1\x01\x2D\xBA\xFB\x9E"
			"\x91\xD8\xFC\x54\x69\x75\x79\x0C\xE6\x4D\xF2\x86\xAC\xBF\x14\x04\x95\x51\xBA"
			"\x27\xD3\xEF\x41\x76\x9B\xDF\x74\x71\xC8\x72\x34\xA7\xF2\x79\x6A\x88\x17\x11"
			"\x29\xCF\xD4\xE3\xCC\x00\xAE\x5A\x1A\x11\x22\x9F\x7C\xCA\xD0\x18\xA5\x66\x9A"
			"\x99\x62\x28\xFE\x33\xA5\xC0\x24\xF2\xCE\x06\xF7\xA6\x1C\x97\x28\x13\x6E";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/dlies1024.dat", true, new HexDecoder);
		DLIES<SHA1,CompatibleCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		DLIES<SHA1,CompatibleCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

#if 0
		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "1024-bit, CompatCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;
#endif

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// 2048 modulus, SHA1
		static const size_t size = 1144;
		static const byte cipher[size+1] =
			"\x17\x48\x21\x11\xC8\x87\xDB\x41\x9A\x75\x6D\x1B\xF4\xCB\x8A\x82\xA2\x65\x87"
			"\x9F\xFA\xCB\x07\x8C\xBE\x22\x08\x90\x71\xA4\xB8\xC1\xD8\x44\x33\x03\xF7\x5F"
			"\xEA\x18\x57\xA9\x95\xD1\x8A\xC5\x29\x8F\xF8\x48\x04\x63\xC7\x43\xDD\x34\x04"
			"\x56\x4C\xD4\xC3\x4A\x98\xC0\x8C\x3E\xC4\x7B\xE3\x6B\xE1\x01\x2D\xBA\xFB\x9E"
			"\x91\xD8\xFC\x54\x69\x75\x79\x0C\xE6\x4D\xF2\x86\xAC\xBF\x14\x04\x95\x51\xBA"
			"\x27\xD3\xEF\x41\x76\x9B\xDF\x74\x71\xC8\x72\x34\xA7\xF2\x79\x6A\x88\x17\x11"
			"\x29\xCF\xD4\xE3\xCC\x00\xAE\x5A\x1A\x11\x22\x9F\x7C\xCA\xD0\x18\xA5\x66\x9A"
			"\x99\x62\x28\xFE\x33\xA5\xC0\x24\xF2\xCE\x06\xF7\xA6\x1C\x97\x28\x13\x6E\x77"
			"\xFB\x87\x81\xC8\xC1\xF4\xC4\x1C\x90\x09\x09\x00\x3B\x78\x16\xAA\x38\x21\xD3"
			"\x71\x93\xFB\x5E\x2E\xD6\xC5\x74\x40\xDC\x2E\xE7\x0F\x2A\x2E\x38\x82\xC5\xB1"
			"\x9F\x27\xEC\x93\x34\x98\x67\x3A\x63\x98\xF8\xD0\x56\x75\x34\x52\x1F\x9D\xAA"
			"\x1C\xF7\x3A\x17\x61\xD8\xE4\x94\x1C\x57\xEC\x20\xDF\xA8\x09\xA4\x73\xDD\x8A"
			"\xD5\xBC\x8B\x0A\x22\x18\x32\xB6\x41\xEE\x74\xC9\x27\xB5\xC6\xCA\xB7\x6D\x1E"
			"\x7A\x8F\x04\x61\xFB\x00\x25\xB3\xDC\xDE\xB9\xDA\xA8\xA5\x39\x54\x08\x59\x12"
			"\xD2\x68\xA9\xAC\x90\x12\x2C\x96\xED\x8D\x4A\x7E\xAC\x9E\xF2\xA7\x1B\xCF\x47"
			"\xEE\x85\x2A\x1C\x42\x97\x5E\xF9\x04\xFE\x1B\x2B\x06\x7C\xE0\xC5\x2C\xA7\xD9"
			"\x76\x3B\x00\x7A\xF6\x78\xC1\xE4\x15\x2A\x29\xC4\xB8\x5B\xF6\xD7\x61\xE0\xDF"
			"\xE4\x61\xA8\xA8\xDC\x45\xEE\x2A\x07\x71\x4E\xF3\xBB\xA3\x15\xFC\x28\x0D\xF3"
			"\x1F\x88\x76\xCC\x56\xA9\xBE\xB6\x47\x0C\x94\xA3\x37\x3C\xDB\x22\xD5\x8E\x1A"
			"\x2A\x23\xAE\xCC\x4A\xFC\x52\x6B\x3A\x37\xF8\xF3\x71\x4E\x51\x3B\x1B\xED\x5B"
			"\x08\x21\x5F\x27\x96\xD7\x80\xD0\x6B\x0F\xD8\xB3\x0B\xAB\x48\xB4\x42\xC0\xFA"
			"\x25\x9E\x32\x79\x87\x61\x68\x28\x6F\x18\x77\xD8\x12\xA8\xED\x3D\xE7\xC6\xAE"
			"\xA8\xBE\xDC\xF6\x72\x33\xDD\x01\xAB\xE2\x34\xAB";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/dlies2048.dat", true, new HexDecoder);
		DLIES<SHA1,CompatibleCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		DLIES<SHA1,CompatibleCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

#if 0
		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "2048-bit, CompatCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;
#endif

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	return pass;
}

// Test data generated with Crypto++ 5.6.2.
bool ValidateLegacyECIES()
{
	std::cout << "\nLegacy ECIES validation suite running...\n\n";

	bool pass = true, fail;
	static const char plain[4] = {'a','b','c'};

	{
		// secp160r1, SHA1
		static const size_t size = 64;
		static const byte cipher[size+1] =
			"\x04\xF9\xF8\x82\x8F\xFE\xA3\x47\x92\xE7\xF9\x6B\x19\xE4\x0D\x36\x2B\xA7\x26\xD3"
			"\x43\x17\x99\x3B\xCA\x37\xEB\x3A\x7C\xC4\xCE\x08\x9E\x23\x37\x75\x8B\xCD\x61\xF2"
			"\x44\x88\x0C\x69\x32\xCE\xFA\x0E\x2E\x7B\x09\xA0\xEB\x18\xD8\x0D\x28\xF8\xFF\x4A"
			"\xB2\x06\x7B\xB2";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp160.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp160r1, NoCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// secp256r1, SHA1
		static const size_t size = 88;
		static const byte cipher[size+1] =
			"\x04\x69\x90\x56\xC6\x19\xDF\xCF\xEE\x61\x5C\x25\x00\xAB\x21\x63\xD0\xE4\x99\x7C"
			"\x29\x42\x31\xBF\x93\x4B\x73\x7D\xD0\xD3\x02\xBA\x4D\xA8\xE2\xCF\x4B\x1A\xB2\xBB"
			"\xB5\x49\xE0\x79\x59\x1D\xC9\x07\xCC\x20\x96\x2F\xD6\x21\x9C\x07\x55\x92\xC8\x9C"
			"\x58\x3D\x1C\x9A\x3F\xF2\x8D\x02\x72\x79\xCC\x17\x0A\xEB\xC7\xAB\xF1\x20\xEB\xCD"
			"\x52\xEB\xC2\x0C\xAC\x8F\x17\x00";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp256.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp256r1, NoCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// secp384r1, SHA1
		static const size_t size = 120;
		static const byte cipher[size+1] =
			"\x04\xA5\xF1\xB3\x24\xFE\x82\x62\x47\x10\xA0\xE9\xC9\xA0\x17\x86\xC9\x82\x39\xC1"
			"\x18\x51\x23\x40\x3A\x85\x5E\x89\xDD\x72\xA8\xC4\xF2\x71\xE7\xC4\x61\x1A\xFF\xE8"
			"\xBF\xA2\x7F\xBB\xDF\x60\x96\x04\x54\x05\xD5\x27\x86\xCF\x73\xBF\x43\x2C\x65\x77"
			"\xA4\xE2\xD5\x3B\xC8\x6A\xF6\x87\x8B\x70\x9E\xEF\x1E\x53\x20\x23\x9E\xA5\xA8\xA0"
			"\x72\x9C\x96\x11\x8E\x48\xFB\xBE\x8D\x32\x03\x8D\x9D\x7C\xDA\x2B\x47\xFA\x20\x9E"
			"\x15\x0D\xB8\x7A\x06\x95\xA8\x78\xB8\x40\x21\x24\x45\xC5\x90\x5B\xD7\x8F\xFA\xD7";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp384.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp384r1, NoCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// secp521r1, SHA1
		static const size_t size = 156;
		static const byte cipher[size+1] =
			"\x04\x01\x00\x62\xC1\x03\x83\x8E\x96\x81\x27\xBA\x59\x27\x42\xF1\x9F\x5E\x00\x7F"
			"\xD2\x0F\xE9\x46\xC3\xFE\x23\x14\xD1\xDF\xCF\xE8\x3A\x94\xDD\xEE\xDD\x3D\x25\x0C"
			"\xC7\x70\x38\x44\x9A\x99\x50\x57\xD9\x9C\x50\x62\xC9\x54\x09\x8E\xEB\xFA\xD0\xCE"
			"\xD5\x8A\xCA\x71\x7D\x71\x0E\x00\x61\x25\x6D\xB6\x33\x40\x25\xCA\x44\xD3\xE3\xC0"
			"\xE9\x2F\xD7\x6C\xAF\xB2\x54\x00\x71\xFF\xE5\x0D\xD6\x7E\xF8\x22\x4B\x75\x4B\xE7"
			"\xA8\x6A\x99\x7F\x84\x6D\x7D\xC2\x9F\x2A\x12\x3C\xDF\xAC\xD3\xD0\x66\x41\x8D\x34"
			"\x16\x30\xB4\x2A\xDF\xA2\x0F\x72\x4A\xC6\x8D\xEA\x8D\x27\x38\x7B\x42\xEF\x4E\x01"
			"\x8F\x22\x4A\x50\x4A\x89\x76\xAD\xB2\xB2\xAA\xC2\x5F\x25\xFF\xA3";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp521.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp521r1, NoCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

#if 0
	{
		// secp160r1, SHA1
		static const size_t size = 234;
		static const byte cipher[size+1] =
			"\x04\x8C\x7D\xC9\xFC\x86\x8C\xB7\x06\xD5\x08\xE5\x77\x5A\x01\x53\x9F\x73\xB8"
			"\x53\xA5\xE7\xC7\x71\x8B\xEB\x46\xEE\xF4\xE0\x0C\xC6\x0D\xC6\x3A\xE3\x3E\xB1"
			"\xB9\x1C\x29\x30\xFC\x3D\xD4\xEA\x5E\x30\xC4\x04\xA6\xE6\xD1\x43\x3C\xBD\x04";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp160.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(64));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp160r1, CompatCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// secp256r1, SHA1
		static const size_t size = 152*4+8*2;
		static const byte cipher[size+1] =
			"\x04\x8C\x7D\xC9\xFC\x86\x8C\xB7\x06\xD5\x08\xE5\x77\x5A\x01\x53\x9F\x73\xB8"
			"\x53\xA5\xE7\xC7\x71\x8B\xEB\x46\xEE\xF4\xE0\x0C\xC6\x0D\xC6\x3A\xE3\x3E\xB1"
			"\xB9\x1C\x29\x30\xFC\x3D\xD4\xEA\x5E\x30\xC4\x04\xA6\xE6\xD1\x43\x3C\xBD\x04"
			"\xCD\xCD\x85\xC6\xAC\x46\xE0\x04\xCB\x59\x9C\xA2\x78\xE6\x57\x0B\xC0\x52\xD9"
			"\x87\x39\x7B\xE7\xB8\xDC\xF3\x87\x01\x5C\x9F\x9A\xF2\x2E\x3F\xBD\x94\x26\x64"
			"\xF1\xA5\x08\x50\xE2\x6A\xE9\x91\x8B\xF5\x70\x09\xDC\x78\x9A\xC4\x97\xEE\x3E"
			"\xC5\x1F\xDD\x48\xCA\xDF\xF0\x93\xA4\xE4\x38\x1D\x55\x0D\xAB\x86\x6B\x30\x1D"
			"\x90\x59\xC0\xA3\x75\x8E\x84\x75\x8D\x86\x8A\xF8\x5A\xA7\x85\x90\x78\xAC\x95";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp256.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp256r1, CompatCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// secp384r1, SHA1
		static const size_t size = 272*4+15*2;
		static const byte cipher[size+1] =
			"\x04\x8C\x7D\xC9\xFC\x86\x8C\xB7\x06\xD5\x08\xE5\x77\x5A\x01\x53\x9F\x73\xB8"
			"\x53\xA5\xE7\xC7\x71\x8B\xEB\x46\xEE\xF4\xE0\x0C\xC6\x0D\xC6\x3A\xE3\x3E\xB1"
			"\xB9\x1C\x29\x30\xFC\x3D\xD4\xEA\x5E\x30\xC4\x04\xA6\xE6\xD1\x43\x3C\xBD\x04"
			"\xCD\xCD\x85\xC6\xAC\x46\xE0\x04\xCB\x59\x9C\xA2\x78\xE6\x57\x0B\xC0\x52\xD9"
			"\x87\x39\x7B\xE7\xB8\xDC\xF3\x87\x01\x5C\x9F\x9A\xF2\x2E\x3F\xBD\x94\x26\x64"
			"\xF1\xA5\x08\x50\xE2\x6A\xE9\x91\x8B\xF5\x70\x09\xDC\x78\x9A\xC4\x97\xEE\x3E"
			"\xC5\x1F\xDD\x48\xCA\xDF\xF0\x93\xA4\xE4\x38\x1D\x55\x0D\xAB\x86\x6B\x30\x1D"
			"\x90\x59\xC0\xA3\x75\x8E\x84\x75\x8D\x86\x8A\xF8\x5A\xA7\x85\x90\x78\xAC\x95"
			"\x04\x03\x6C\x6C\x38\x14\x95\x86\xF4\x89\xD3\xA9\x53\x5A\xFC\x77\x41\x90\x25"
			"\xB5\xC0\x31\x05\x9F\xC8\x75\xD5\xD3\x5D\x56\x6B\xBD\x3B\x92\x4C\xF8\xB0\x9E"
			"\xF5\xCE\x2E\x5F\xFE\x38\xDC\x13\xB4\x13\x76\xA6\x14\x6A\xE0\x4E\x1C\x5D\xE5"
			"\x96\x2C\xE2\x34\x9A\x1D\xA8\xB3\x99\xD1\x75\x21\x82\x0B\x41\x33\xEB\x35\x02"
			"\x9F\xE5\x20\xF0\xE0\xF4\x8D\xF2\x40\x73\x44\xC0\x26\xB3\xF7\x9D\xDB\xE0\x5A"
			"\xBE\xE6\x3B\x81\x29\xD5\xB3\x50\x83\x14\xFC\xA7\x3D\xCE\x5C\xFB\xEA\xAD\x3E"
			"\x5C\xE3\xD5\x9F\xBA\x5F";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp384.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp384r1, CompatCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// secp521r1, SHA1
		static const size_t size = 428*4+23*2;
		static const byte cipher[size+1] =
			"\x04\x8C\x7D\xC9\xFC\x86\x8C\xB7\x06\xD5\x08\xE5\x77\x5A\x01\x53\x9F\x73\xB8"
			"\x53\xA5\xE7\xC7\x71\x8B\xEB\x46\xEE\xF4\xE0\x0C\xC6\x0D\xC6\x3A\xE3\x3E\xB1"
			"\xB9\x1C\x29\x30\xFC\x3D\xD4\xEA\x5E\x30\xC4\x04\xA6\xE6\xD1\x43\x3C\xBD\x04"
			"\xCD\xCD\x85\xC6\xAC\x46\xE0\x04\xCB\x59\x9C\xA2\x78\xE6\x57\x0B\xC0\x52\xD9"
			"\x87\x39\x7B\xE7\xB8\xDC\xF3\x87\x01\x5C\x9F\x9A\xF2\x2E\x3F\xBD\x94\x26\x64"
			"\xF1\xA5\x08\x50\xE2\x6A\xE9\x91\x8B\xF5\x70\x09\xDC\x78\x9A\xC4\x97\xEE\x3E"
			"\xC5\x1F\xDD\x48\xCA\xDF\xF0\x93\xA4\xE4\x38\x1D\x55\x0D\xAB\x86\x6B\x30\x1D"
			"\x90\x59\xC0\xA3\x75\x8E\x84\x75\x8D\x86\x8A\xF8\x5A\xA7\x85\x90\x78\xAC\x95"
			"\x04\x03\x6C\x6C\x38\x14\x95\x86\xF4\x89\xD3\xA9\x53\x5A\xFC\x77\x41\x90\x25"
			"\xB5\xC0\x31\x05\x9F\xC8\x75\xD5\xD3\x5D\x56\x6B\xBD\x3B\x92\x4C\xF8\xB0\x9E"
			"\xF5\xCE\x2E\x5F\xFE\x38\xDC\x13\xB4\x13\x76\xA6\x14\x6A\xE0\x4E\x1C\x5D\xE5"
			"\x96\x2C\xE2\x34\x9A\x1D\xA8\xB3\x99\xD1\x75\x21\x82\x0B\x41\x33\xEB\x35\x02"
			"\x9F\xE5\x20\xF0\xE0\xF4\x8D\xF2\x40\x73\x44\xC0\x26\xB3\xF7\x9D\xDB\xE0\x5A"
			"\xBE\xE6\x3B\x81\x29\xD5\xB3\x50\x83\x14\xFC\xA7\x3D\xCE\x5C\xFB\xEA\xAD\x3E"
			"\x5C\xE3\xD5\x9F\xBA\x5F\x04\x00\x83\x58\x23\xD8\x6F\x3D\x22\xCB\x6F\xB4\x97"
			"\xED\x27\x98\xA1\x99\x53\xBC\x5A\x5D\xD4\x0D\xC5\x40\x03\x31\x50\xFB\xA9\x1A"
			"\xAD\x7D\xC0\x53\x8B\xF6\xDB\x62\xB3\x6D\xA9\xCB\xB2\x36\x18\xC7\x5B\x8B\xA5"
			"\x94\x9B\x34\xC7\x34\x9C\x43\x01\xE1\x35\x52\x0C\x69\xC4\xAC\xF2\x01\x1B\x5F"
			"\x38\x2D\xEE\x29\x47\xCE\xBA\x97\xE9\x3A\x5B\x5C\x0A\xDC\x33\x54\x14\x5F\x4B"
			"\x5B\x75\x87\x59\x20\xC1\x07\x1F\xF0\x32\xF6\xCF\x28\x5E\xFC\x50\x39\xBE\x36"
			"\xA1\x49\xEA\xA1\x95\x28\x08\xB7\x41\x5F\x63\xBA\xBB\x48\x6B\x94\x9B\x2F\xA5"
			"\x20\x06\x34\x94\x2D\x0E\x09\x88\xD4\x4A\xE8\x9E\x7B\x02\xD8\xF0\x36\x8E\x9A"
			"\x9D\x20\x6B\xC0\x6B\x67\x9B\x5A\x9F\xD5";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp521.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp521r1, CompatCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}
#endif

	return pass;
}

bool ValidateInteropDLIES()
{
	std::cout << "\nInteroperable DLIES validation suite running...\n\n";

	return true;
}

bool ValidateInteropECIES()
{
	std::cout << "\nInteroperable ECIES validation suite running...\n\n";

	return true;
}
